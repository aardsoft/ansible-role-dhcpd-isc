#jinja2: lstrip_blocks: True
# {{ ansible_managed }}
#
# DHCP Server Configuration file.
#   see dhcpd.conf(5) man page
#

{% if dns_domain is undefined and dhcp_default_domain is defined %}
{% set dns_domain = dhcp_default_domain %}
{% endif %}

if known {
    log (info, concat ("HOSTNAME: ", host-decl-name, " on ",binary-to-ascii (10, 8, ".", leased-address)," at ", binary-to-ascii (16, 8, ":", substring (hardware, 1, 6))));
}

# DHCP classes are global, so only basic settings are possible here.
# Until it's clear how matching in shared network sections is possible
# only one global PXE/HTTP filename is supported, and PXE and HTTP flags
# must not override each other. (pool is theoretically capable of doing the
# matching, but not really an option as it requires range specifications)
{% if dhcp_pxe_filename is defined %}
class "pxeclients" {
    match if substring (option vendor-class-identifier, 0, 9) = "PXEClient";
    filename "{{dhcp_pxe_filename}}";
}
{% endif %}

{% if dhcp_pxe_filename is defined %}
class "httpclients" {
    match if substring (option vendor-class-identifier, 0, 10) = "HTTPClient";
    filename "{{dhcp_http_filename}}";
    option vendor-class-identifier "HTTPClient";
}
{% endif %}

{# Create an option space, and create options prefixed with the option #}
{# space name (vendor name). A configuration block may look like this: #}
{#                                                                     #}
{# dhcp_optionspaces:                                                  #}
{#   SUNW:                                                             #}
{#     options:                                                        #}
{#       - "root-mount-options code 1 = text"                          #}
{#       - "root-server-ip-address code 2 = ip-address"                #}
{#                                                                     #}
{% if dhcp_optionspaces is defined %}
  {% for optionspace in dhcp_optionspaces %}
option space {{ optionspace }};
  {% for option in dhcp_optionspaces[optionspace].options %}
option {{optionspace}}.{{option}};
  {% endfor %}
  {% endfor %}
{% endif %}

{# loop over global options from `dhcp_options`. Those are not magically #}
{# prefixed with 'options' to allow arbitrary configuration directives.  #}
{% if dhcp_options is defined %}
 {% for option in dhcp_options %}
{{option}};
 {% endfor %}
{% endif %}

{# also todo: add dynamic ranges #}

{% for vlan in vlans %}
{# vlan_data is used to store network address and mask of each subnet, to be #}
{# cleared in each loop. This way we can make sure configuration shows up in #}
{# the correct VLan _and_ the correct subnet. This finally filters some IP   #}
{# addresses on public interfaces we don't really want, and as bonus adds    #}
{# proper support for multiple subnets in a VLan                             #}
{% set vlan_data = {} %}
{% if dhcp_networks[vlan] is defined %}
shared-network {{vlan}} {
  {# loop over shared-network specific options #}
  {% if dhcp_networks[vlan].options is defined %}
   {% for option in dhcp_networks[vlan].options %}
  {{option}};
   {% endfor %}
  {% endif %}
  {# loop over the subnet definitions #}
  {% for subnet in dhcp_networks[vlan].subnets %}
    {% if dhcp_networks[vlan].subnets[subnet].netmask is defined %}
      {# doing this inline throws very ugly templating errors - so it's easier #}
      {# to debug to not catch this error, and figure out later why dhcpd is   #}
      {# no longer starting                                                    #}
      {% set nw_with_mask = subnet + "/" + dhcp_networks[vlan].subnets[subnet].netmask %}
      {% set network = nw_with_mask | ipaddr('network') %}
      {% set netmask = nw_with_mask | ipaddr('netmask') %}
      {% set first_ip = nw_with_mask | ipaddr('net') | ipaddr('1') | ipaddr('address') %}
      {% set last_ip = nw_with_mask | ipaddr('net') | ipaddr('-1') | ipaddr('address') %}
      {% if vlan_data.update({network: netmask}) %}{% endif %}
  subnet {{subnet}} netmask {{dhcp_networks[vlan].subnets[subnet].netmask}} {
    {% else %}
    {# this is not ideal - if the subnet is defined without mask this will #}
    {# generate an empty subnet declaration, breaking dhcp on restart.     #}
    {# Unfortunately there's no built-in way to throw errors from jinja    #}
      {% set network = subnet | ipaddr('network') %}
      {% set netmask = subnet | ipaddr('netmask') %}
      {% set first_ip = subnet | ipaddr('net') | ipaddr('1') | ipaddr('address') %}
      {% set last_ip = subnet | ipaddr('net') | ipaddr('-1') | ipaddr('address') %}
      {% if vlan_data.update({network: netmask}) %}{% endif %}
  subnet {{subnet | ipaddr('network')}} netmask {{subnet | ipaddr('netmask')}} {
    {% endif %}
    {% if vlan == 'default' %}
    {% set dhcp_domain_name = '"' + dns_domain + '"' %}
    {% set dhcp_domain_search = '"' + dns_domain + '", "' + vlan + "." + dns_domain + '"' %}
    {% else %}
    {% set dhcp_domain_name =  '"' + vlan + "." + dns_domain + '"' %}
    {% set dhcp_domain_search = '"' + vlan + "." + dns_domain + '", "' + dns_domain + '"' %}
    {% endif %}
    option domain-name {{ dhcp_domain_name }};
    option domain-search {{ dhcp_domain_search }};

    {% if dhcp_networks[vlan].subnets[subnet].boot_options is defined %}
      {% for boot_option in dhcp_networks[vlan].subnets[subnet].boot_options %}
        {# TODO: add arch_conditional subkeys to build conditional boot structure #}
        {% if boot_option == "pxe" %}
        # PXE specific flags
          {% for option in dhcp_networks[vlan].subnets[subnet].boot_options.pxe %}
      {{option}};
          {% endfor %}
        {% elif boot_option == "http" %}
        # HTTP boot specific flags
          {% for option in dhcp_networks[vlan].subnets[subnet].boot_options.http %}
      {{option}};
          {% endfor %}
        {% else %}
  # unknown boot category: {{ boot_option }}
        {% endif %}
      {% endfor %}
    {% endif %}

    {% if dhcp_networks[vlan].subnets[subnet].options is defined %}
      {% for option in dhcp_networks[vlan].subnets[subnet].options %}
    {{option}};
      {% endfor %}
    {% endif %}
  } # end of subnet
  {% endfor %}
  # vlan_data: {{ vlan_data }}
  group {
{% for node in network_nodes %}
 {% if network_nodes[node].networks is defined %}
   {% for network in network_nodes[node].networks %}
     {% set iface = network_nodes[node].networks[network] %}
     {# default values for dns name and vlan, in case no configuration is #}
     {# is found in the next steps.                                       #}
     {# Empty vlan is treated as 'default'. Interfaces with an assigned   #}
     {# vlan or built on top of vlan (like bridges) need to change this   #}
     {# value in the next section. It is used to figure out which DHCP    #}
     {# section is correct for placing the interface.                     #}
     {# Due to 'interesting' scoping of jinja variables this needs to be  #}
     {# a dict which is updated later on. 'set' variables can't be edited #}
     {# in a different scope.                                             #}
     {% set dns = {'name': node + '.' + dns_domain, 'vlan': "default"} %}
     {# figure out if the interface directly or indirectly belongs to a VLan #}
     {# this is required to put the interface configuration into the correct #}
     {# configuration section                                                #}
     {% if iface.vlan is defined %}
       {# with a vlan the hostname is name.vlan.dns_domain #}
       {% if dns.update({'vlan': iface.vlan }) %}{% endif %}
       {% if dns.update({'name': node + '.' + iface.vlan + '.' + dns_domain}) %}{% endif %}
     {% elif iface.type is defined and iface.type == "bridge" %}
       {# loop over the network configuration to find the interface under the bridge #}
       {% for tmp_net in network_nodes[node].networks %}
         {% set tmp_iface = network_nodes[node].networks[tmp_net] %}
         {% if tmp_iface.bridge is defined and tmp_iface.bridge == network %}
           {% if tmp_iface.vlan is defined %}
             {% if dns.update({'vlan': tmp_iface.vlan}) %}{% endif %}
             {% if dns.update({'name': node + '.' + tmp_iface.vlan + '.' + dns_domain}) %}{% endif %}
             {# TODO: import loop controls to break out of for #}
           {% endif %}
         {% endif %}
       {% endfor %}
     {% elif network_nodes[node].type is defined and network_nodes[node].type == "lxc" and network_nodes[node].networks[network].link is defined %}
       {# virtual nodes are interesting, as first the network devices on the #}
       {# physical host need to be looked up, followed by the same discovery #}
       {# dance as above with the bridge/...                                 #}
       {% set tmp_node = network_nodes[node].machine %}
       {% set tmp_link = network_nodes[node].networks[network].link %}
       {# loop over the network configuration to find the interface under the bridge #}
       {% for tmp_net in network_nodes[tmp_node].networks %}
         {% set tmp_iface = network_nodes[tmp_node].networks[tmp_net] %}
         {% if tmp_iface.bridge is defined and tmp_iface.bridge == tmp_link %}
           {% if tmp_iface.vlan is defined %}
             {% if dns.update({'vlan': tmp_iface.vlan}) %}{% endif %}
             {# as it's just for checking the vlan dns name update is not needed here #}
             {# TODO: import loop controls to break out of for #}
           {% endif %}
         {% endif %}
       {% endfor %}
     {% endif %}
     {# if a dns attribute is used take this as hostname, overriding DNS   #}
     {# names calculated earlier. Without trailing dot the dns_domain will #}
     {# still be appended (but not the vlan)                               #}
     {% if iface.dns is defined %}
       {% if iface.dns.endswith('.') %}
         {% if dns.update({'name': iface.dns }) %}{% endif %}
       {% else %}
         {% if dns.update({'name': iface.dns + '.' + dns_domain + '.'}) %}{% endif %}
       {% endif %}
     {% endif %}
     {# loop over the vlans subnets to make sure only entries with IPs matching #}
     {# the subnet show up here                                                 #}
     {% for data in vlan_data %}
     {% if vlan == dns.vlan and iface.hwaddr is defined and iface.ipv4 is defined %}
       {% set iface_address = iface.ipv4 | ipaddr('address') %}
       {% set iface_address_with_netmask = iface_address + "/" + vlan_data[data] %}
       {% set iface_network =  iface_address_with_netmask | ipaddr('network') %}
       {% if data == iface_network %}
         {% if dns.name.endswith('.') %}
         {# double dots are a syntax error in dhcpd configuration #}
    host {{dns.name}}{{network}}{
         {% else %}
    host {{dns.name}}.{{network}}{
         {% endif %}
          hardware ethernet {{iface.hwaddr}};
          fixed-address {{iface_address}};
         {% if iface.dhcp_options is defined %}
           {% for option in iface.dhcp_options %}
          {{option}};
           {% endfor %}
         {% endif %}
    } # end of host
       {% endif %}
     {% endif %}
     {% endfor %}
   {% endfor %}
 {% endif %}
{% endfor %}
  } # end of shared-network
}
{% else %}
# skipping undefined vlan {{vlan}}
{% endif %}
{% endfor %}